{"version":3,"file":"index.cjs","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport { type PluginWithOptions } from \"markdown-it\";\nimport { type RuleBlock } from \"markdown-it/lib/parser_block.js\";\nimport { type RuleInline } from \"markdown-it/lib/parser_inline.js\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.js\";\n\nimport { type MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Test if potential opening or closing delimiter\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevChar = pos > 0 ? state.src.charAt(pos - 1) : \"\";\n  const nextChar = pos + 1 <= state.posMax ? state.src.charAt(pos + 1) : \"\";\n\n  return {\n    canOpen: allowInlineWithSpace || (nextChar !== \" \" && nextChar !== \"\\t\"),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isnâ€™t followed by a number\n     */\n    canClose:\n      !/[0-9]/u.exec(nextChar) &&\n      (allowInlineWithSpace || (prevChar !== \" \" && prevChar !== \"\\t\")),\n  };\n};\n\nconst getInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    let match;\n    let pos;\n    let res;\n    let token;\n\n    if (state.src[state.pos] !== \"$\") return false;\n\n    res = isValidDelim(state, state.pos, allowInlineWithSpace);\n    if (!res.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos += 1;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    match = start;\n    while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src[pos] === \"\\\\\") pos -= 1;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match += 1;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match, allowInlineWithSpace);\n\n    if (!res.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      token = state.push(\"math_inline\", \"math\", 0);\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\nconst blockTex: RuleBlock = (state, start, end, silent) => {\n  let firstLine;\n  let lastLine;\n  let next;\n  let lastPos;\n  let found = false;\n  let pos = state.bMarks[start] + state.tShift[start];\n  let max = state.eMarks[start];\n\n  if (pos + 2 > max) return false;\n\n  if (state.src.slice(pos, pos + 2) !== \"$$\") return false;\n\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n\n  if (silent) return true;\n\n  if (firstLine.trim().endsWith(\"$$\")) {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  for (next = start; !found; ) {\n    next += 1;\n\n    if (next >= end) break;\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent)\n      // non-empty line with negative indent should stop the list:\n      break;\n\n    if (state.src.slice(pos, max).trim().endsWith(\"$$\")) {\n      lastPos = state.src.slice(0, max).lastIndexOf(\"$$\");\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine?.trim() ? `\\n${firstLine}\\n` : \"\\n\") +\n    state.getLines(start + 1, next, state.tShift[start], true) +\n    (lastLine?.trim() ? lastLine : \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    render,\n  } = options || {};\n\n  if (typeof render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      return fence!(...args);\n    };\n  }\n\n  md.inline.ruler.after(\n    \"escape\",\n    \"math_inline\",\n    getInlineTex(allowInlineWithSpace),\n  );\n  md.block.ruler.after(\"blockquote\", \"math_block\", blockTex, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[\"math_inline\"] = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules[\"math_block\"] = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["isValidDelim","state","pos","allowInlineWithSpace","prevChar","nextChar","getInlineTex","silent","match","res","token","start","blockTex","end","firstLine","lastLine","next","lastPos","found","max","tex","md","options","mathFence","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"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"}